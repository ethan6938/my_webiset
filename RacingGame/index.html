<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drag Race Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  <style>
    :root{
      --bg:#111; --fg:#fff; --muted:#444; --ring:#88f;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
    }
    #menu {
      position: absolute; inset: 0;
      background: var(--bg);
      display: grid;
      place-items: center;
      z-index: 2;
      padding: 24px;
    }
    .menu-inner{
      display:flex; flex-direction:column; gap:32px; align-items:center;
      max-width: 960px; width:100%;
    }
    .row{display:flex; flex-wrap:wrap; gap:24px; justify-content:center}
    .section {display:flex; flex-direction:column; align-items:center; gap:10px; min-width:260px;}
    .choices {display:flex; gap:15px; flex-wrap:wrap; justify-content:center}
    .choice {
      width: 110px; height: 72px; object-fit: cover;
      cursor: pointer;
      border: 3px solid transparent;
      border-radius: 10px;
      transition: transform 120ms, border-color 120ms;
      outline: none;
    }
    .choice:hover { transform: translateY(-2px); }
    .choice[aria-selected="true"] { border-color: var(--fg); }
    .choice:focus-visible{ box-shadow: 0 0 0 3px var(--ring); }
    button {
      padding: 12px 28px;
      font-size: 18px;
      background: var(--muted);
      color: var(--fg);
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
    button:focus-visible{ outline:3px solid var(--ring) }
    #phaser-example { display:none; width:100vw; height:100vh; }
    #hud {
      position: absolute; top: 20px; left: 20px; z-index: 3;
      display: none; flex-direction: column; gap: 12px;
    }
    .hud-btn {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 16px; color: var(--fg);
      background: rgba(0,0,0,0.4);
      padding: 8px 12px; border: 2px solid var(--fg);
      border-radius: 8px; cursor: pointer;
    }
    #speedometer {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 20px; color: var(--fg);
      background: rgba(0,0,0,0.4);
      padding: 8px 12px; border-radius: 8px;
      min-width: 180px;
    }
  </style>
</head>
<body>
  <!-- MENU -->
  <div id="menu" aria-label="Main menu">
    <div class="menu-inner">
      <div class="row">
        <div class="section">
          <h2>Select Track</h2>
          <div class="choices" id="track-choices" role="listbox" aria-label="Track choices">
            <img class="choice" src="images/track.png"  data-value="track"  alt="Track Easy"   tabindex="0" aria-selected="true">
            <img class="choice" src="images/track2.png" data-value="track2" alt="Track Medium" tabindex="0">
            <img class="choice" src="images/track3.png" data-value="track3" alt="Track Hard"   tabindex="0">
          </div>
        </div>
        <div class="section">
          <h2>Select Car</h2>
          <div class="choices" id="car-choices" role="listbox" aria-label="Car choices">
            <img class="choice" src="images/car.png"  data-value="car"  alt="Car 1" tabindex="0" aria-selected="true">
            <img class="choice" src="images/car2.png" data-value="car2" alt="Car 2" tabindex="0">
          </div>
        </div>
      </div>
      <button id="start-btn" aria-label="Start race">Start Race</button>
    </div>
  </div>

  <!-- GAME & HUD -->
  <div id="phaser-example" aria-hidden="true"></div>
  <div id="hud" aria-live="polite">
    <div id="speedometer">Speed: 0 km/h</div>
    <div style="display:flex; gap:8px;">
      <button class="hud-btn" id="game-start-btn">Start</button>
      <button class="hud-btn" id="restart-btn">Restart</button>
      <button class="hud-btn" id="back-btn">Back</button>
    </div>
  </div>

  <script>
  (() => {
    // -------------------------
    // Config & shared state
    // -------------------------
    const SPEED_LIMIT_KMH = 700;
    const ACCEL_PLAYER = 200;
    const ACCEL_OPPONENT = 150;
    const DRAG_PLAYER = 300;

    const TRACK_LENGTHS = {
      track: 1000,   // Easy
      track2: 1800,  // Medium
      track3: 2600   // Hard
    };

    const GameState = {
      track: 'track',
      car: 'car',
      started: false,
      phaser: null,
    };

    const els = {
      menu: document.getElementById('menu'),
      startBtn: document.getElementById('start-btn'),
      phaserMount: document.getElementById('phaser-example'),
      hud: document.getElementById('hud'),
      speedo: document.getElementById('speedometer'),
      hudStart: document.getElementById('game-start-btn'),
      hudRestart: document.getElementById('restart-btn'),
      hudBack: document.getElementById('back-btn'),
      trackChoices: document.getElementById('track-choices'),
      carChoices: document.getElementById('car-choices'),
    };

    // -------------------------
    // UI helpers
    // -------------------------
    function setSelected(listEl, target) {
      Array.from(listEl.querySelectorAll('.choice')).forEach(el => {
        el.setAttribute('aria-selected', String(el === target));
      });
    }

    function attachChoiceDelegation(listEl, onChoose) {
      listEl.addEventListener('click', (e) => {
        const img = e.target.closest('.choice');
        if (!img) return;
        setSelected(listEl, img);
        onChoose(img.dataset.value);
      });
      listEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          const img = e.target.closest('.choice');
          if (!img) return;
          e.preventDefault();
          setSelected(listEl, img);
          onChoose(img.dataset.value);
        }
      });
    }

    function toggleViews(showGame) {
      els.menu.style.display = showGame ? 'none' : 'grid';
      els.phaserMount.style.display = showGame ? 'block' : 'none';
      els.phaserMount.setAttribute('aria-hidden', showGame ? 'false' : 'true');
      els.hud.style.display = showGame ? 'flex' : 'none';
    }

    function getFinishDistance(trackKey) {
      return TRACK_LENGTHS[trackKey] || TRACK_LENGTHS.track;
    }

    // -------------------------
    // Scene
    // -------------------------
    class DragRace extends Phaser.Scene {
      constructor() {
        super('DragRace');
        this.finished = false;
        this.boundHandlers = null;
      }

      preload() {
        // Preload chosen assets
        this.load.image('track', `images/${GameState.track}.png`);
        this.load.image('car',   `images/${GameState.car}.png`);
        // Opponent is the other sprite
        const opponentKey = GameState.car === 'car' ? 'car2' : 'car';
        this.load.image('car2', `images/${opponentKey}.png`);
      }

      create() {
        const finishDistance = getFinishDistance(GameState.track);

        // Scrolling track
        this.track = this.add.tileSprite(0, 0, this.scale.width, finishDistance, 'track')
          .setOrigin(0, 0)
          .setScrollFactor(1);

        // Physics world bounds
        this.physics.world.setBounds(0, 0, this.scale.width, finishDistance);

        // Cars
        const cx = this.scale.width / 2;
        this.car = this.physics.add.sprite(cx - 100, finishDistance - 100, 'car').setScale(0.25);
        this.opponent = this.physics.add.sprite(cx + 100, finishDistance - 100, 'car2').setScale(0.25);

        this.car.setCollideWorldBounds(true);
        this.opponent.setCollideWorldBounds(true);

        // Camera follows player
        this.cameras.main.startFollow(this.car, true, 0.15, 0.15);
        this.cameras.main.setBounds(0, 0, this.scale.width, finishDistance);

        // Input
        this.keys = this.input.keyboard.addKeys({ accel: 'W' });

        // Finish line (static zone)
        this.finishLine = this.add.zone(this.scale.width / 2, 100, this.scale.width, 20);
        this.physics.add.existing(this.finishLine, true); // static body

        // Overlaps
        this.physics.add.overlap(this.car, this.finishLine, () => this.playerWins(), null, this);
        this.physics.add.overlap(this.opponent, this.finishLine, () => this.opponentWins(), null, this);

        // Hook HUD controls (one set of bound handlers per scene lifetime)
        this.bindHUD();

        // Resize handling (keeps camera/track correct)
        this.scale.on('resize', this.onResize, this);
        this.events.on('shutdown', this.onShutdown, this);
        this.events.on('destroy', this.onShutdown, this);
      }

      bindHUD() {
        const startHandler = () => { GameState.started = true; this.car.setAccelerationY(0); };
        const restartHandler = () => { GameState.started = false; this.scene.restart(); };
        const backHandler = () => { this.game.destroy(true); GameState.phaser = null; GameState.started = false; toggleViews(false); };

        els.hudStart.addEventListener('click', startHandler);
        els.hudRestart.addEventListener('click', restartHandler);
        els.hudBack.addEventListener('click', backHandler);

        // Keep for cleanup
        this.boundHandlers = { startHandler, restartHandler, backHandler };
      }

      onResize(gameSize) {
        const { width, height } = gameSize;
        this.cameras.main.setViewport(0, 0, width, height);
        // Note: track tilesprite height remains = finish distance; width adapts visually by camera
      }

      update() {
        if (this.finished || !GameState.started) return;

        const maxSpeedPx = (SPEED_LIMIT_KMH / 3.6); // px/s
        // Player accel/brake
        if (this.keys.accel.isDown) {
          if (this.car.body.velocity.y > -maxSpeedPx) {
            this.car.setAccelerationY(-ACCEL_PLAYER);
            this.car.setDragY(0);
          } else {
            this.car.setAccelerationY(0);
          }
        } else {
          this.car.setAccelerationY(0);
          this.car.setDragY(DRAG_PLAYER);
        }

        // Opponent "AI": 90% of player top speed
        if (this.opponent.body.velocity.y > -(maxSpeedPx * 0.9)) {
          this.opponent.setAccelerationY(-ACCEL_OPPONENT);
        } else {
          this.opponent.setAccelerationY(0);
        }

        // Speedometer
        const speedKmh = Math.max(0, Math.round(Math.abs(this.car.body.velocity.y) * 3.6));
        els.speedo.textContent = `Speed: ${speedKmh} km/h`;
      }

      playerWins() {
        if (this.finished) return;
        this.finished = true;
        GameState.started = false;
        alert('ðŸ You Win!');
      }

      opponentWins() {
        if (this.finished) return;
        this.finished = true;
        GameState.started = false;
        alert('ðŸ’¥ Opponent Wins!');
      }

      onShutdown() {
        // Remove HUD listeners to avoid duplicates after restart/destroy
        if (this.boundHandlers) {
          els.hudStart.removeEventListener('click', this.boundHandlers.startHandler);
          els.hudRestart.removeEventListener('click', this.boundHandlers.restartHandler);
          els.hudBack.removeEventListener('click', this.boundHandlers.backHandler);
          this.boundHandlers = null;
        }
        this.scale.off('resize', this.onResize, this);
      }
    }

    // -------------------------
    // Game bootstrap
    // -------------------------
    function startGame() {
      if (GameState.phaser) {
        // Already running; just show it
        toggleViews(true);
        return;
      }
      GameState.started = false;

      const game = new Phaser.Game({
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: '#111',
        parent: 'phaser-example',
        physics: {
          default: 'arcade',
          arcade: { gravity: { y: 0 }, debug: false }
        },
        scene: DragRace,
        scale: {
          mode: Phaser.Scale.RESIZE,
          autoCenter: Phaser.Scale.CENTER_BOTH
        }
      });

      GameState.phaser = game;
      toggleViews(true);
    }

    // -------------------------
    // Wire menu interactions
    // -------------------------
    attachChoiceDelegation(els.trackChoices, (value) => { GameState.track = value; });
    attachChoiceDelegation(els.carChoices,   (value) => { GameState.car = value; });

    els.startBtn.addEventListener('click', () => {
      startGame();
    });

    // Allow browser Back button to mean "Back to menu" if desired:
    // history.pushState(null, '', location.href);
    // window.addEventListener('popstate', () => {
    //   if (GameState.phaser) { GameState.phaser.destroy(true); GameState.phaser = null; }
    //   toggleViews(false);
    // });

  })();
  </script>
</body>
</html>
