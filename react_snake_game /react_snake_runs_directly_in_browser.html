<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Snake (No Build Tools)</title>
  <style>
    :root{ --bg:#0b0f14; --panel:#0f1622; --text:#e6edf3; --muted:#9fb0c0; --accent:#4cc2ff; --good:#22c55e; --danger:#ef4444; }
    *{box-sizing:border-box}
    body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text);}
    .wrap{max-width:560px; margin:20px auto; padding:12px}
    .bar{display:flex; align-items:center; justify-content:space-between; gap:.5rem; background:var(--panel); border:1px solid #1b2739; border-radius:14px; padding:10px 12px}
    button{appearance:none; border:1px solid #334156; background:linear-gradient(180deg,#1a2840,#142038); color:var(--text); padding:.5rem .8rem; border-radius:12px; cursor:pointer}
    button:hover{transform:translateY(-1px)}
    canvas{width:100%; height:auto; display:block; background:#08101a; border:1px solid #1a2333; border-radius:14px}
    .hud{display:flex; gap:.5rem; margin-top:8px; flex-wrap:wrap}
    .tag{background:#0e1521; border:1px solid #1b2739; padding:.35rem .6rem; border-radius:999px; font-size:.9rem}

    .overlay{position:absolute; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.7)}
    .screen{background:#0e1521; border:1px solid #1b2739; border-radius:16px; padding:20px; text-align:center; max-width:90vw}
    .kbd{border:1px solid #334156; background:#0e1622; padding:.12rem .35rem; border-radius:.3rem}

    .pad{display:flex; gap:6px; justify-content:center; margin-top:10px}
    .pad button{background:#0e1622}
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React 18 + ReactDOM (UMD), and Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useRef, useState, useEffect } = React;

    function App(){
      const canvasRef = useRef(null);
      const containerRef = useRef(null);
      const timerRef = useRef(0);
      const runningRef = useRef(false);
      const pausedRef = useRef(false);

      // Grid
      const gridRef = useRef({ cols: 22, rows: 30, tile: 24, dpr: 1 });
      // Game state (in refs so we don't re-render every tick)
      const snakeRef = useRef([]); // array of {x,y}, head at index 0
      const dirRef = useRef({x:1,y:0});
      const nextDirRef = useRef({x:1,y:0});
      const foodRef = useRef({x:8,y:8});
      const speedRef = useRef(140); // ms per step, speeds up as you eat

      // UI state
      const [score, setScore] = useState(0);
      const [best, setBest] = useState(()=>{
        const v = parseInt(localStorage.getItem('rxs.best')||'0',10);
        return Number.isFinite(v) ? v : 0;
      });
      const [level, setLevel] = useState(1);
      const [showStart, setShowStart] = useState(true);
      const [showOver, setShowOver] = useState(false);

      // Helpers
      const randInt = (a,b)=> (Math.random()*(b-a+1)+a)|0; // inclusive
      const eq = (a,b)=> a.x===b.x && a.y===b.y;
      const inside = (p)=> p.x>=0 && p.y>=0 && p.x<gridRef.current.cols && p.y<gridRef.current.rows;

      function initSnake(){
        const { cols, rows } = gridRef.current;
        const midX = (cols/2)|0, midY = (rows/2)|0;
        snakeRef.current = [ {x:midX, y:midY}, {x:midX-1, y:midY}, {x:midX-2, y:midY} ];
        dirRef.current = {x:1,y:0};
        nextDirRef.current = {x:1,y:0};
        placeFood();
      }
      function placeFood(){
        const { cols, rows } = gridRef.current;
        while(true){
          const p = { x: randInt(0, cols-1), y: randInt(0, rows-1) };
          if(!snakeRef.current.some(s=> eq(s,p))){ foodRef.current = p; return; }
        }
      }

      // Canvas fit + DPR
      useEffect(()=>{
        const c = canvasRef.current; const wrap = containerRef.current;
        const fit = ()=>{
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
          const maxCSS = Math.min(560, wrap?.clientWidth||560);
          const cols = 22; const rows = 30; const tile = Math.floor(maxCSS/cols);
          gridRef.current = { cols, rows, tile, dpr };
          c.style.width = `${cols*tile}px`;
          c.style.height = `${rows*tile}px`;
          c.width = Math.round(cols*tile*dpr);
          c.height = Math.round(rows*tile*dpr);
          draw();
        };
        fit();
        window.addEventListener('resize', fit);
        return ()=> window.removeEventListener('resize', fit);
      }, []);

      // Keyboard controls
      useEffect(()=>{
        const onDown = (e)=>{
          const k = e.key.toLowerCase();
          if(k==='arrowleft'||k==='a') turn(-1,0);
          else if(k==='arrowright'||k==='d') turn(1,0);
          else if(k==='arrowup'||k==='w') turn(0,-1);
          else if(k==='arrowdown'||k==='s') turn(0,1);
          else if(k===' '){ if(runningRef.current) togglePause(); }
          else if(k==='enter'){ if(!runningRef.current) onStart(); }
        };
        addEventListener('keydown', onDown);
        return ()=> removeEventListener('keydown', onDown);
      }, []);

      function onStart(){
        setScore(0); setLevel(1); speedRef.current=140;
        runningRef.current=true; pausedRef.current=false; setShowStart(false); setShowOver(false);
        initSnake();
        scheduleNext();
      }
      function onReset(){
        runningRef.current=false; pausedRef.current=false; clearTimeout(timerRef.current);
        setShowStart(true); setShowOver(false); setScore(0); setLevel(1);
        initSnake(); draw();
      }
      function gameOver(){
        runningRef.current=false; clearTimeout(timerRef.current);
        setShowOver(true);
        setBest(b=>{ const nv=Math.max(b, Math.floor(score)); localStorage.setItem('rxs.best', String(nv)); return nv; });
      }
      function togglePause(){
        if(!runningRef.current) return;
        pausedRef.current=!pausedRef.current;
        if(!pausedRef.current) scheduleNext();
      }
      function turn(x,y){
        const cur = dirRef.current; if(cur.x===-x && cur.y===-y) return; // no 180
        nextDirRef.current = {x,y};
      }

      function scheduleNext(){ clearTimeout(timerRef.current); timerRef.current = setTimeout(step, speedRef.current); }

      function step(){
        if(!runningRef.current || pausedRef.current) return;
        dirRef.current = nextDirRef.current; const dir = dirRef.current;
        const head = snakeRef.current[0];
        const next = { x: head.x + dir.x, y: head.y + dir.y };
        if(!inside(next) || snakeRef.current.some(s=> eq(s,next))){ gameOver(); draw(); return; }
        snakeRef.current.unshift(next);
        if(eq(next, foodRef.current)){
          setScore(s=> s+10);
          placeFood();
          speedRef.current = Math.max(70, speedRef.current - 4); // speed up
          setLevel(l=> l + ((l%4===0)?1:0));
        } else {
          snakeRef.current.pop();
        }
        draw();
        scheduleNext();
      }

      function draw(){
        const c = canvasRef.current; if(!c) return; const ctx = c.getContext('2d');
        const { cols, rows, tile, dpr } = gridRef.current;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.clearRect(0,0, cols*tile, rows*tile);
        // background
        ctx.fillStyle = '#0a1220'; ctx.fillRect(0,0, cols*tile, rows*tile);
        // grid lines
        ctx.strokeStyle='rgba(255,255,255,.06)'; ctx.lineWidth=1; ctx.beginPath();
        for(let x=0;x<cols;x++){ ctx.moveTo(x*tile,0); ctx.lineTo(x*tile,rows*tile); }
        for(let y=0;y<rows;y++){ ctx.moveTo(0,y*tile); ctx.lineTo(cols*tile,y*tile); }
        ctx.stroke();
        // food
        ctx.fillStyle= getComputedStyle(document.documentElement).getPropertyValue('--good') || '#22c55e';
        const fx = foodRef.current.x*tile + tile/2, fy = foodRef.current.y*tile + tile/2;
        ctx.beginPath(); ctx.arc(fx,fy, Math.min(8, tile*0.35), 0, Math.PI*2); ctx.fill();
        // snake
        for(const s of snakeRef.current){
          const x = s.x*tile, y = s.y*tile, r = Math.max(4, Math.floor(tile*0.25));
          const g = ctx.createLinearGradient(x,y,x,y+tile); g.addColorStop(0,'#4cc2ff'); g.addColorStop(1,'#1a6aa1');
          ctx.fillStyle=g; ctx.strokeStyle='#08121c'; ctx.lineWidth=2;
          roundRect(ctx, x+2, y+2, tile-4, tile-4, r, true, true);
        }
        // HUD
        ctx.fillStyle='rgba(255,255,255,.85)'; ctx.font='14px ui-sans-serif,system-ui';
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 18);
        ctx.fillText(`Best: ${best}`, 10, 36);
        ctx.fillText(`Level: ${level}`, 10, 54);
      }

      function roundRect(ctx,x,y,w,h,r,fill,stroke){
        if(w<2*r) r=w/2; if(h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y);
        ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
        ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
        if(fill) ctx.fill(); if(stroke) ctx.stroke();
      }

      useEffect(()=> ()=> { clearTimeout(timerRef.current); }, []);

      return (
        <div ref={containerRef} className="wrap">
          <div className="bar">
            <div style={{fontWeight:700, letterSpacing:'.2px'}}>üêç React Snake</div>
            <div style={{display:'flex', gap:'.4rem'}}>
              <button onClick={onStart}>‚ñ∂Ô∏è Start</button>
              <button onClick={togglePause}>‚è∏Ô∏è Pause</button>
              <button onClick={onReset} style={{background:'linear-gradient(180deg,#3a1313,#2b1010)', borderColor:'#7f2626'}}>üîÑ Reset</button>
            </div>
          </div>

          <div style={{position:'relative', marginTop:'10px'}}>
            <canvas ref={canvasRef}></canvas>
            {showStart && (
              <div className="overlay" onClick={onStart}>
                <div className="screen" onClick={(e)=>e.stopPropagation()}>
                  <h1 style={{margin:'0 0 6px'}}>React Snake</h1>
                  <p className="muted">Eat the green apples. Don‚Äôt hit the walls or yourself.</p>
                  <p className="muted">Move with <span className="kbd">‚Üê</span>/<span className="kbd">‚Üí</span>/<span className="kbd">‚Üë</span>/<span className="kbd">‚Üì</span> or WASD.</p>
                  <div style={{marginTop:'10px'}}>
                    <button onClick={onStart}>‚ñ∂Ô∏è Play</button>
                  </div>
                </div>
              </div>
            )}
            {showOver && (
              <div className="overlay" onClick={()=>{ setShowOver(false); onStart(); }}>
                <div className="screen" onClick={(e)=> e.stopPropagation()}>
                  <h2 style={{margin:'0 0 6px'}}>Game Over</h2>
                  <p>Score: <b>{Math.floor(score)}</b> ¬∑ Best: <b>{best}</b></p>
                  <div style={{marginTop:'10px'}}>
                    <button onClick={()=>{ setShowOver(false); onStart(); }}>üîÅ Try Again</button>
                  </div>
                </div>
              </div>
            )}
          </div>

          <div className="hud">
            <div className="tag">Score: <b>{Math.floor(score)}</b></div>
            <div className="tag">Best: <b>{best}</b></div>
            <div className="tag">Level: <b>{level}</b></div>
          </div>

          <div className="pad">
            <button onClick={()=>turn(-1,0)}>‚¨ÖÔ∏è</button>
            <button onClick={()=>turn(0,-1)}>‚¨ÜÔ∏è</button>
            <button onClick={()=>turn(0,1)}>‚¨áÔ∏è</button>
            <button onClick={()=>turn(1,0)}>‚û°Ô∏è</button>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>
